// 6 april 2015

// TODO add a uiVerifyControlType() function that can be used by control implementations to verify controls

// TODOs
// - make getters that return whether something exists accept a NULL pointer to discard the value (and thus only return that the thing exists?)
// - const-correct everything
// - normalize documentation between typedefs and structs

import core.stdc.stdint;

extern (C):

// this macro is generated by cmake

// TODO add __declspec(dllimport) on windows, but only if not static

// C++ is really really really really really really dumb about enums, so screw that and just make them anonymous
// This has the advantage of being ABI-able should we ever need an ABI...

// This constant is provided because M_PI is nonstandard.
// This comes from Go's math.Pi, which in turn comes from http://oeis.org/A000796.
enum uiPi = 3.14159265358979323846264338327950288419716939937510582097494459;

// TODO uiBool?

// uiForEach represents the return value from one of libui's various ForEach functions.
alias uiForEach = uint;

enum
{
    uiForEachContinue = 0,
    uiForEachStop = 1
}

struct uiInitOptions
{
    size_t Size;
}

const(char)* uiInit (uiInitOptions* options);
void uiUninit ();
void uiFreeInitError (const(char)* err);

void uiMain ();
void uiMainSteps ();
int uiMainStep (int wait);
void uiQuit ();

void uiQueueMain (void function (void* data) f, void* data);

// TODO standardize the looping behavior return type, either with some enum or something, and the test expressions throughout the code
// TODO figure out what to do about looping and the exact point that the timer is rescheduled so we can document it; see https://github.com/andlabs/libui/pull/277
// TODO (also in the above link) document that this cannot be called from any thread, unlike uiQueueMain()
// TODO document that the minimum exact timing, either accuracy (timer burst, etc.) or granularity (15ms on Windows, etc.), is OS-defined
// TODO also figure out how long until the initial tick is registered on all platforms to document
// TODO also add a comment about how useful this could be in bindings, depending on the language being bound to
void uiTimer (int milliseconds, int function (void* data) f, void* data);

void uiOnShouldQuit (int function (void* data) f, void* data);

void uiFreeText (char* text);

struct uiControl
{
    uint Signature;
    uint OSSignature;
    uint TypeSignature;
    void function (uiControl*) Destroy;
    uintptr_t function (uiControl*) Handle;
    uiControl* function (uiControl*) Parent;
    void function (uiControl*, uiControl*) SetParent;
    int function (uiControl*) Toplevel;
    int function (uiControl*) Visible;
    void function (uiControl*) Show;
    void function (uiControl*) Hide;
    int function (uiControl*) Enabled;
    void function (uiControl*) Enable;
    void function (uiControl*) Disable;
}

void uiControlDestroy (uiControl*);
uintptr_t uiControlHandle (uiControl*);
uiControl* uiControlParent (uiControl*);
void uiControlSetParent (uiControl*, uiControl*);
int uiControlToplevel (uiControl*);
int uiControlVisible (uiControl*);
void uiControlShow (uiControl*);
void uiControlHide (uiControl*);
int uiControlEnabled (uiControl*);
void uiControlEnable (uiControl*);
void uiControlDisable (uiControl*);

uiControl* uiAllocControl (size_t n, uint OSsig, uint typesig, const(char)* typenamestr);
void uiFreeControl (uiControl*);

// TODO make sure all controls have these
void uiControlVerifySetParent (uiControl*, uiControl*);
int uiControlEnabledToUser (uiControl*);

void uiUserBugCannotSetParentOnToplevel (const(char)* type);

struct uiWindow;
char* uiWindowTitle (uiWindow* w);
void uiWindowSetTitle (uiWindow* w, const(char)* title);
void uiWindowContentSize (uiWindow* w, int* width, int* height);
void uiWindowSetContentSize (uiWindow* w, int width, int height);
int uiWindowFullscreen (uiWindow* w);
void uiWindowSetFullscreen (uiWindow* w, int fullscreen);
void uiWindowOnContentSizeChanged (uiWindow* w, void function (uiWindow*, void*) f, void* data);
void uiWindowOnClosing (uiWindow* w, int function (uiWindow* w, void* data) f, void* data);
int uiWindowBorderless (uiWindow* w);
void uiWindowSetBorderless (uiWindow* w, int borderless);
void uiWindowSetChild (uiWindow* w, uiControl* child);
int uiWindowMargined (uiWindow* w);
void uiWindowSetMargined (uiWindow* w, int margined);
uiWindow* uiNewWindow (const(char)* title, int width, int height, int hasMenubar);

struct uiButton;
char* uiButtonText (uiButton* b);
void uiButtonSetText (uiButton* b, const(char)* text);
void uiButtonOnClicked (uiButton* b, void function (uiButton* b, void* data) f, void* data);
uiButton* uiNewButton (const(char)* text);

struct uiBox;
void uiBoxAppend (uiBox* b, uiControl* child, int stretchy);
void uiBoxDelete (uiBox* b, int index);
int uiBoxPadded (uiBox* b);
void uiBoxSetPadded (uiBox* b, int padded);
uiBox* uiNewHorizontalBox ();
uiBox* uiNewVerticalBox ();

struct uiCheckbox;
char* uiCheckboxText (uiCheckbox* c);
void uiCheckboxSetText (uiCheckbox* c, const(char)* text);
void uiCheckboxOnToggled (uiCheckbox* c, void function (uiCheckbox* c, void* data) f, void* data);
int uiCheckboxChecked (uiCheckbox* c);
void uiCheckboxSetChecked (uiCheckbox* c, int checked);
uiCheckbox* uiNewCheckbox (const(char)* text);

struct uiEntry;
char* uiEntryText (uiEntry* e);
void uiEntrySetText (uiEntry* e, const(char)* text);
void uiEntryOnChanged (uiEntry* e, void function (uiEntry* e, void* data) f, void* data);
int uiEntryReadOnly (uiEntry* e);
void uiEntrySetReadOnly (uiEntry* e, int readonly);
uiEntry* uiNewEntry ();
uiEntry* uiNewPasswordEntry ();
uiEntry* uiNewSearchEntry ();

struct uiLabel;
char* uiLabelText (uiLabel* l);
void uiLabelSetText (uiLabel* l, const(char)* text);
uiLabel* uiNewLabel (const(char)* text);

struct uiTab;
void uiTabAppend (uiTab* t, const(char)* name, uiControl* c);
void uiTabInsertAt (uiTab* t, const(char)* name, int before, uiControl* c);
void uiTabDelete (uiTab* t, int index);
int uiTabNumPages (uiTab* t);
int uiTabMargined (uiTab* t, int page);
void uiTabSetMargined (uiTab* t, int page, int margined);
uiTab* uiNewTab ();

struct uiGroup;
char* uiGroupTitle (uiGroup* g);
void uiGroupSetTitle (uiGroup* g, const(char)* title);
void uiGroupSetChild (uiGroup* g, uiControl* c);
int uiGroupMargined (uiGroup* g);
void uiGroupSetMargined (uiGroup* g, int margined);
uiGroup* uiNewGroup (const(char)* title);

// spinbox/slider rules:
// setting value outside of range will automatically clamp
// initial value is minimum
// complaint if min >= max?

struct uiSpinbox;
int uiSpinboxValue (uiSpinbox* s);
void uiSpinboxSetValue (uiSpinbox* s, int value);
void uiSpinboxOnChanged (uiSpinbox* s, void function (uiSpinbox* s, void* data) f, void* data);
uiSpinbox* uiNewSpinbox (int min, int max);

struct uiSlider;
int uiSliderValue (uiSlider* s);
void uiSliderSetValue (uiSlider* s, int value);
void uiSliderOnChanged (uiSlider* s, void function (uiSlider* s, void* data) f, void* data);
uiSlider* uiNewSlider (int min, int max);

struct uiProgressBar;
int uiProgressBarValue (uiProgressBar* p);
void uiProgressBarSetValue (uiProgressBar* p, int n);
uiProgressBar* uiNewProgressBar ();

struct uiSeparator;
uiSeparator* uiNewHorizontalSeparator ();
uiSeparator* uiNewVerticalSeparator ();

struct uiCombobox;
void uiComboboxAppend (uiCombobox* c, const(char)* text);
int uiComboboxSelected (uiCombobox* c);
void uiComboboxSetSelected (uiCombobox* c, int n);
void uiComboboxOnSelected (uiCombobox* c, void function (uiCombobox* c, void* data) f, void* data);
uiCombobox* uiNewCombobox ();

struct uiEditableCombobox;
void uiEditableComboboxAppend (uiEditableCombobox* c, const(char)* text);
char* uiEditableComboboxText (uiEditableCombobox* c);
void uiEditableComboboxSetText (uiEditableCombobox* c, const(char)* text);
// TODO what do we call a function that sets the currently selected item and fills the text field with it? editable comboboxes have no consistent concept of selected item
void uiEditableComboboxOnChanged (uiEditableCombobox* c, void function (uiEditableCombobox* c, void* data) f, void* data);
uiEditableCombobox* uiNewEditableCombobox ();

struct uiRadioButtons;
void uiRadioButtonsAppend (uiRadioButtons* r, const(char)* text);
int uiRadioButtonsSelected (uiRadioButtons* r);
void uiRadioButtonsSetSelected (uiRadioButtons* r, int n);
void uiRadioButtonsOnSelected (uiRadioButtons* r, void function (uiRadioButtons*, void*) f, void* data);
uiRadioButtons* uiNewRadioButtons ();

struct tm;
struct uiDateTimePicker;
// TODO document that tm_wday and tm_yday are undefined, and tm_isdst should be -1
// TODO document that for both sides
// TODO document time zone conversions or lack thereof
// TODO for Time: define what values are returned when a part is missing
void uiDateTimePickerTime (uiDateTimePicker* d, tm* time);
void uiDateTimePickerSetTime (uiDateTimePicker* d, const(tm)* time);
void uiDateTimePickerOnChanged (uiDateTimePicker* d, void function (uiDateTimePicker*, void*) f, void* data);
uiDateTimePicker* uiNewDateTimePicker ();
uiDateTimePicker* uiNewDatePicker ();
uiDateTimePicker* uiNewTimePicker ();

// TODO provide a facility for entering tab stops?
struct uiMultilineEntry;
char* uiMultilineEntryText (uiMultilineEntry* e);
void uiMultilineEntrySetText (uiMultilineEntry* e, const(char)* text);
void uiMultilineEntryAppend (uiMultilineEntry* e, const(char)* text);
void uiMultilineEntryOnChanged (uiMultilineEntry* e, void function (uiMultilineEntry* e, void* data) f, void* data);
int uiMultilineEntryReadOnly (uiMultilineEntry* e);
void uiMultilineEntrySetReadOnly (uiMultilineEntry* e, int readonly);
uiMultilineEntry* uiNewMultilineEntry ();
uiMultilineEntry* uiNewNonWrappingMultilineEntry ();

struct uiMenuItem;
void uiMenuItemEnable (uiMenuItem* m);
void uiMenuItemDisable (uiMenuItem* m);
void uiMenuItemOnClicked (uiMenuItem* m, void function (uiMenuItem* sender, uiWindow* window, void* data) f, void* data);
int uiMenuItemChecked (uiMenuItem* m);
void uiMenuItemSetChecked (uiMenuItem* m, int checked);

struct uiMenu;
uiMenuItem* uiMenuAppendItem (uiMenu* m, const(char)* name);
uiMenuItem* uiMenuAppendCheckItem (uiMenu* m, const(char)* name);
uiMenuItem* uiMenuAppendQuitItem (uiMenu* m);
uiMenuItem* uiMenuAppendPreferencesItem (uiMenu* m);
uiMenuItem* uiMenuAppendAboutItem (uiMenu* m);
void uiMenuAppendSeparator (uiMenu* m);
uiMenu* uiNewMenu (const(char)* name);

char* uiOpenFile (uiWindow* parent);
char* uiSaveFile (uiWindow* parent);
void uiMsgBox (uiWindow* parent, const(char)* title, const(char)* description);
void uiMsgBoxError (uiWindow* parent, const(char)* title, const(char)* description);

struct uiArea;

struct uiDrawContext;

struct uiAreaHandler
{
    void function (uiAreaHandler*, uiArea*, uiAreaDrawParams*) Draw;
    // TODO document that resizes cause a full redraw for non-scrolling areas; implementation-defined for scrolling areas
    void function (uiAreaHandler*, uiArea*, uiAreaMouseEvent*) MouseEvent;
    // TODO document that on first show if the mouse is already in the uiArea then one gets sent with left=0
    // TODO what about when the area is hidden and then shown again?
    void function (uiAreaHandler*, uiArea*, int left) MouseCrossed;
    void function (uiAreaHandler*, uiArea*) DragBroken;
    int function (uiAreaHandler*, uiArea*, uiAreaKeyEvent*) KeyEvent;
}

// TODO RTL layouts?
// TODO reconcile edge and corner naming
alias uiWindowResizeEdge = uint;

enum
{
    uiWindowResizeEdgeLeft = 0,
    uiWindowResizeEdgeTop = 1,
    uiWindowResizeEdgeRight = 2,
    uiWindowResizeEdgeBottom = 3,
    uiWindowResizeEdgeTopLeft = 4,
    uiWindowResizeEdgeTopRight = 5,
    uiWindowResizeEdgeBottomLeft = 6,
    uiWindowResizeEdgeBottomRight = 7
    // TODO have one for keyboard resizes?
    // TODO GDK doesn't seem to have any others, including for keyboards...
    // TODO way to bring up the system menu instead?
}
// TODO give a better name
// TODO document the types of width and height
void uiAreaSetSize (uiArea* a, int width, int height);
// TODO uiAreaQueueRedraw()
void uiAreaQueueRedrawAll (uiArea* a);
void uiAreaScrollTo (uiArea* a, double x, double y, double width, double height);
// TODO document these can only be called within Mouse() handlers
// TODO should these be allowed on scrolling areas?
// TODO decide which mouse events should be accepted; Down is the only one guaranteed to work right now
// TODO what happens to events after calling this up to and including the next mouse up?
// TODO release capture?
void uiAreaBeginUserWindowMove (uiArea* a);
void uiAreaBeginUserWindowResize (uiArea* a, uiWindowResizeEdge edge);
uiArea* uiNewArea (uiAreaHandler* ah);
uiArea* uiNewScrollingArea (uiAreaHandler* ah, int width, int height);

struct uiAreaDrawParams
{
    uiDrawContext* Context;

    // TODO document that this is only defined for nonscrolling areas
    double AreaWidth;
    double AreaHeight;

    double ClipX;
    double ClipY;
    double ClipWidth;
    double ClipHeight;
}

struct uiDrawPath;

alias uiDrawBrushType = uint;

enum
{
    uiDrawBrushTypeSolid = 0,
    uiDrawBrushTypeLinearGradient = 1,
    uiDrawBrushTypeRadialGradient = 2,
    uiDrawBrushTypeImage = 3
}

alias uiDrawLineCap = uint;

enum
{
    uiDrawLineCapFlat = 0,
    uiDrawLineCapRound = 1,
    uiDrawLineCapSquare = 2
}

alias uiDrawLineJoin = uint;

enum
{
    uiDrawLineJoinMiter = 0,
    uiDrawLineJoinRound = 1,
    uiDrawLineJoinBevel = 2
}

// this is the default for botoh cairo and Direct2D (in the latter case, from the C++ helper functions)
// Core Graphics doesn't explicitly specify a default, but NSBezierPath allows you to choose one, and this is the initial value
// so we're good to use it too!
enum uiDrawDefaultMiterLimit = 10.0;

alias uiDrawFillMode = uint;

enum
{
    uiDrawFillModeWinding = 0,
    uiDrawFillModeAlternate = 1
}

struct uiDrawMatrix
{
    double M11;
    double M12;
    double M21;
    double M22;
    double M31;
    double M32;
}

struct uiDrawBrush
{
    uiDrawBrushType Type;

    // solid brushes
    double R;
    double G;
    double B;
    double A;

    // gradient brushes
    double X0; // linear: start X, radial: start X
    double Y0; // linear: start Y, radial: start Y
    double X1; // linear: end X, radial: outer circle center X
    double Y1; // linear: end Y, radial: outer circle center Y
    double OuterRadius; // radial gradients only
    uiDrawBrushGradientStop* Stops;
    size_t NumStops;
    // TODO extend mode
    // cairo: none, repeat, reflect, pad; no individual control
    // Direct2D: repeat, reflect, pad; no individual control
    // Core Graphics: none, pad; before and after individually
    // TODO cairo documentation is inconsistent about pad

    // TODO images

    // TODO transforms
}

struct uiDrawBrushGradientStop
{
    double Pos;
    double R;
    double G;
    double B;
    double A;
}

struct uiDrawStrokeParams
{
    uiDrawLineCap Cap;
    uiDrawLineJoin Join;
    // TODO what if this is 0? on windows there will be a crash with dashing
    double Thickness;
    double MiterLimit;
    double* Dashes;
    // TOOD what if this is 1 on Direct2D?
    // TODO what if a dash is 0 on Cairo or Quartz?
    size_t NumDashes;
    double DashPhase;
}

uiDrawPath* uiDrawNewPath (uiDrawFillMode fillMode);
void uiDrawFreePath (uiDrawPath* p);

void uiDrawPathNewFigure (uiDrawPath* p, double x, double y);
void uiDrawPathNewFigureWithArc (uiDrawPath* p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int negative);
void uiDrawPathLineTo (uiDrawPath* p, double x, double y);
// notes: angles are both relative to 0 and go counterclockwise
// TODO is the initial line segment on cairo and OS X a proper join?
// TODO what if sweep < 0?
void uiDrawPathArcTo (uiDrawPath* p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int negative);
void uiDrawPathBezierTo (uiDrawPath* p, double c1x, double c1y, double c2x, double c2y, double endX, double endY);
// TODO quadratic bezier
void uiDrawPathCloseFigure (uiDrawPath* p);

// TODO effect of these when a figure is already started
void uiDrawPathAddRectangle (uiDrawPath* p, double x, double y, double width, double height);

void uiDrawPathEnd (uiDrawPath* p);

void uiDrawStroke (uiDrawContext* c, uiDrawPath* path, uiDrawBrush* b, uiDrawStrokeParams* p);
void uiDrawFill (uiDrawContext* c, uiDrawPath* path, uiDrawBrush* b);

// TODO primitives:
// - rounded rectangles
// - elliptical arcs
// - quadratic bezier curves

void uiDrawMatrixSetIdentity (uiDrawMatrix* m);
void uiDrawMatrixTranslate (uiDrawMatrix* m, double x, double y);
void uiDrawMatrixScale (uiDrawMatrix* m, double xCenter, double yCenter, double x, double y);
void uiDrawMatrixRotate (uiDrawMatrix* m, double x, double y, double amount);
void uiDrawMatrixSkew (uiDrawMatrix* m, double x, double y, double xamount, double yamount);
void uiDrawMatrixMultiply (uiDrawMatrix* dest, uiDrawMatrix* src);
int uiDrawMatrixInvertible (uiDrawMatrix* m);
int uiDrawMatrixInvert (uiDrawMatrix* m);
void uiDrawMatrixTransformPoint (uiDrawMatrix* m, double* x, double* y);
void uiDrawMatrixTransformSize (uiDrawMatrix* m, double* x, double* y);

void uiDrawTransform (uiDrawContext* c, uiDrawMatrix* m);

// TODO add a uiDrawPathStrokeToFill() or something like that
void uiDrawClip (uiDrawContext* c, uiDrawPath* path);

void uiDrawSave (uiDrawContext* c);
void uiDrawRestore (uiDrawContext* c);

// uiAttribute stores information about an attribute in a
// uiAttributedString.
//
// You do not create uiAttributes directly; instead, you create a
// uiAttribute of a given type using the specialized constructor
// functions. For every Unicode codepoint in the uiAttributedString,
// at most one value of each attribute type can be applied.
//
// uiAttributes are immutable and the uiAttributedString takes
// ownership of the uiAttribute object once assigned, copying its
// contents as necessary.
struct uiAttribute;

// @role uiAttribute destructor
// uiFreeAttribute() frees a uiAttribute. You generally do not need to
// call this yourself, as uiAttributedString does this for you. In fact,
// it is an error to call this function on a uiAttribute that has been
// given to a uiAttributedString. You can call this, however, if you
// created a uiAttribute that you aren't going to use later.
void uiFreeAttribute (uiAttribute* a);

// uiAttributeType holds the possible uiAttribute types that may be
// returned by uiAttributeGetType(). Refer to the documentation for
// each type's constructor function for details on each type.
alias uiAttributeType = uint;

enum
{
    uiAttributeTypeFamily = 0,
    uiAttributeTypeSize = 1,
    uiAttributeTypeWeight = 2,
    uiAttributeTypeItalic = 3,
    uiAttributeTypeStretch = 4,
    uiAttributeTypeColor = 5,
    uiAttributeTypeBackground = 6,
    uiAttributeTypeUnderline = 7,
    uiAttributeTypeUnderlineColor = 8,
    uiAttributeTypeFeatures = 9
}

// uiAttributeGetType() returns the type of a.
// TODO I don't like this name
uiAttributeType uiAttributeGetType (const(uiAttribute)* a);

// uiNewFamilyAttribute() creates a new uiAttribute that changes the
// font family of the text it is applied to. family is copied; you do not
// need to keep it alive after uiNewFamilyAttribute() returns. Font
// family names are case-insensitive.
uiAttribute* uiNewFamilyAttribute (const(char)* family);

// uiAttributeFamily() returns the font family stored in a. The
// returned string is owned by a. It is an error to call this on a
// uiAttribute that does not hold a font family.
const(char)* uiAttributeFamily (const(uiAttribute)* a);

// uiNewSizeAttribute() creates a new uiAttribute that changes the
// size of the text it is applied to, in typographical points.
uiAttribute* uiNewSizeAttribute (double size);

// uiAttributeSize() returns the font size stored in a. It is an error to
// call this on a uiAttribute that does not hold a font size.
double uiAttributeSize (const(uiAttribute)* a);

// uiTextWeight represents possible text weights. These roughly
// map to the OS/2 text weight field of TrueType and OpenType
// fonts, or to CSS weight numbers. The named constants are
// nominal values; the actual values may vary by font and by OS,
// though this isn't particularly likely. Any value between
// uiTextWeightMinimum and uiTextWeightMaximum, inclusive,
// is allowed.
//
// Note that due to restrictions in early versions of Windows, some
// fonts have "special" weights be exposed in many programs as
// separate font families. This is perhaps most notable with
// Arial Black. libui does not do this, even on Windows (because the
// DirectWrite API libui uses on Windows does not do this); to
// specify Arial Black, use family Arial and weight uiTextWeightBlack.
alias uiTextWeight = uint;

enum
{
    uiTextWeightMinimum = 0,
    uiTextWeightThin = 100,
    uiTextWeightUltraLight = 200,
    uiTextWeightLight = 300,
    uiTextWeightBook = 350,
    uiTextWeightNormal = 400,
    uiTextWeightMedium = 500,
    uiTextWeightSemiBold = 600,
    uiTextWeightBold = 700,
    uiTextWeightUltraBold = 800,
    uiTextWeightHeavy = 900,
    uiTextWeightUltraHeavy = 950,
    uiTextWeightMaximum = 1000
}

// uiNewWeightAttribute() creates a new uiAttribute that changes the
// weight of the text it is applied to. It is an error to specify a weight
// outside the range [uiTextWeightMinimum,
// uiTextWeightMaximum].
uiAttribute* uiNewWeightAttribute (uiTextWeight weight);

// uiAttributeWeight() returns the font weight stored in a. It is an error
// to call this on a uiAttribute that does not hold a font weight.
uiTextWeight uiAttributeWeight (const(uiAttribute)* a);

// uiTextItalic represents possible italic modes for a font. Italic
// represents "true" italics where the slanted glyphs have custom
// shapes, whereas oblique represents italics that are merely slanted
// versions of the normal glyphs. Most fonts usually have one or the
// other.
alias uiTextItalic = uint;

enum
{
    uiTextItalicNormal = 0,
    uiTextItalicOblique = 1,
    uiTextItalicItalic = 2
}

// uiNewItalicAttribute() creates a new uiAttribute that changes the
// italic mode of the text it is applied to. It is an error to specify an
// italic mode not specified in uiTextItalic.
uiAttribute* uiNewItalicAttribute (uiTextItalic italic);

// uiAttributeItalic() returns the font italic mode stored in a. It is an
// error to call this on a uiAttribute that does not hold a font italic
// mode.
uiTextItalic uiAttributeItalic (const(uiAttribute)* a);

// uiTextStretch represents possible stretches (also called "widths")
// of a font.
//
// Note that due to restrictions in early versions of Windows, some
// fonts have "special" stretches be exposed in many programs as
// separate font families. This is perhaps most notable with
// Arial Condensed. libui does not do this, even on Windows (because
// the DirectWrite API libui uses on Windows does not do this); to
// specify Arial Condensed, use family Arial and stretch
// uiTextStretchCondensed.
alias uiTextStretch = uint;

enum
{
    uiTextStretchUltraCondensed = 0,
    uiTextStretchExtraCondensed = 1,
    uiTextStretchCondensed = 2,
    uiTextStretchSemiCondensed = 3,
    uiTextStretchNormal = 4,
    uiTextStretchSemiExpanded = 5,
    uiTextStretchExpanded = 6,
    uiTextStretchExtraExpanded = 7,
    uiTextStretchUltraExpanded = 8
}

// uiNewStretchAttribute() creates a new uiAttribute that changes the
// stretch of the text it is applied to. It is an error to specify a strech
// not specified in uiTextStretch.
uiAttribute* uiNewStretchAttribute (uiTextStretch stretch);

// uiAttributeStretch() returns the font stretch stored in a. It is an
// error to call this on a uiAttribute that does not hold a font stretch.
uiTextStretch uiAttributeStretch (const(uiAttribute)* a);

// uiNewColorAttribute() creates a new uiAttribute that changes the
// color of the text it is applied to. It is an error to specify an invalid
// color.
uiAttribute* uiNewColorAttribute (double r, double g, double b, double a);

// uiAttributeColor() returns the text color stored in a. It is an
// error to call this on a uiAttribute that does not hold a text color.
void uiAttributeColor (const(uiAttribute)* a, double* r, double* g, double* b, double* alpha);

// uiNewBackgroundAttribute() creates a new uiAttribute that
// changes the background color of the text it is applied to. It is an
// error to specify an invalid color.
uiAttribute* uiNewBackgroundAttribute (double r, double g, double b, double a);

// TODO reuse uiAttributeColor() for background colors, or make a new function...

// uiUnderline specifies a type of underline to use on text.
alias uiUnderline = uint;

enum
{
    uiUnderlineNone = 0,
    uiUnderlineSingle = 1,
    uiUnderlineDouble = 2,
    uiUnderlineSuggestion = 3 // wavy or dotted underlines used for spelling/grammar checkers
}

// uiNewUnderlineAttribute() creates a new uiAttribute that changes
// the type of underline on the text it is applied to. It is an error to
// specify an underline type not specified in uiUnderline.
uiAttribute* uiNewUnderlineAttribute (uiUnderline u);

// uiAttributeUnderline() returns the underline type stored in a. It is
// an error to call this on a uiAttribute that does not hold an underline
// style.
uiUnderline uiAttributeUnderline (const(uiAttribute)* a);

// uiUnderlineColor specifies the color of any underline on the text it
// is applied to, regardless of the type of underline. In addition to
// being able to specify a custom color, you can explicitly specify
// platform-specific colors for suggestion underlines; to use them
// correctly, pair them with uiUnderlineSuggestion (though they can
// be used on other types of underline as well).
// 
// If an underline type is applied but no underline color is
// specified, the text color is used instead. If an underline color
// is specified without an underline type, the underline color
// attribute is ignored, but not removed from the uiAttributedString.
alias uiUnderlineColor = uint;

enum
{
    uiUnderlineColorCustom = 0,
    uiUnderlineColorSpelling = 1,
    uiUnderlineColorGrammar = 2,
    uiUnderlineColorAuxiliary = 3 // for instance, the color used by smart replacements on macOS or in Microsoft Office
}

// uiNewUnderlineColorAttribute() creates a new uiAttribute that
// changes the color of the underline on the text it is applied to.
// It is an error to specify an underline color not specified in
// uiUnderlineColor.
//
// If the specified color type is uiUnderlineColorCustom, it is an
// error to specify an invalid color value. Otherwise, the color values
// are ignored and should be specified as zero.
uiAttribute* uiNewUnderlineColorAttribute (uiUnderlineColor u, double r, double g, double b, double a);

// uiAttributeUnderlineColor() returns the underline color stored in
// a. It is an error to call this on a uiAttribute that does not hold an
// underline color.
void uiAttributeUnderlineColor (const(uiAttribute)* a, uiUnderlineColor* u, double* r, double* g, double* b, double* alpha);

// uiOpenTypeFeatures represents a set of OpenType feature
// tag-value pairs, for applying OpenType features to text.
// OpenType feature tags are four-character codes defined by
// OpenType that cover things from design features like small
// caps and swashes to language-specific glyph shapes and
// beyond. Each tag may only appear once in any given
// uiOpenTypeFeatures instance. Each value is a 32-bit integer,
// often used as a Boolean flag, but sometimes as an index to choose
// a glyph shape to use.
// 
// If a font does not support a certain feature, that feature will be
// ignored. (TODO verify this on all OSs)
// 
// See the OpenType specification at
// https://www.microsoft.com/typography/otspec/featuretags.htm
// for the complete list of available features, information on specific
// features, and how to use them.
// TODO invalid features
struct uiOpenTypeFeatures;

// uiOpenTypeFeaturesForEachFunc is the type of the function
// invoked by uiOpenTypeFeaturesForEach() for every OpenType
// feature in otf. Refer to that function's documentation for more
// details.
alias uiOpenTypeFeaturesForEachFunc = uint function (const(uiOpenTypeFeatures)* otf, char a, char b, char c, char d, uint value, void* data);

// @role uiOpenTypeFeatures constructor
// uiNewOpenTypeFeatures() returns a new uiOpenTypeFeatures
// instance, with no tags yet added.
uiOpenTypeFeatures* uiNewOpenTypeFeatures ();

// @role uiOpenTypeFeatures destructor
// uiFreeOpenTypeFeatures() frees otf.
void uiFreeOpenTypeFeatures (uiOpenTypeFeatures* otf);

// uiOpenTypeFeaturesClone() makes a copy of otf and returns it.
// Changing one will not affect the other.
uiOpenTypeFeatures* uiOpenTypeFeaturesClone (const(uiOpenTypeFeatures)* otf);

// uiOpenTypeFeaturesAdd() adds the given feature tag and value
// to otf. The feature tag is specified by a, b, c, and d. If there is
// already a value associated with the specified tag in otf, the old
// value is removed.
void uiOpenTypeFeaturesAdd (uiOpenTypeFeatures* otf, char a, char b, char c, char d, uint value);

// uiOpenTypeFeaturesRemove() removes the given feature tag
// and value from otf. If the tag is not present in otf,
// uiOpenTypeFeaturesRemove() does nothing.
void uiOpenTypeFeaturesRemove (uiOpenTypeFeatures* otf, char a, char b, char c, char d);

// uiOpenTypeFeaturesGet() determines whether the given feature
// tag is present in otf. If it is, *value is set to the tag's value and
// nonzero is returned. Otherwise, zero is returned.
// 
// Note that if uiOpenTypeFeaturesGet() returns zero, value isn't
// changed. This is important: if a feature is not present in a
// uiOpenTypeFeatures, the feature is NOT treated as if its
// value was zero anyway. Script-specific font shaping rules and
// font-specific feature settings may use a different default value
// for a feature. You should likewise not treat a missing feature as
// having a value of zero either. Instead, a missing feature should
// be treated as having some unspecified default value.
int uiOpenTypeFeaturesGet (const(uiOpenTypeFeatures)* otf, char a, char b, char c, char d, uint* value);

// uiOpenTypeFeaturesForEach() executes f for every tag-value
// pair in otf. The enumeration order is unspecified. You cannot
// modify otf while uiOpenTypeFeaturesForEach() is running.
void uiOpenTypeFeaturesForEach (const(uiOpenTypeFeatures)* otf, uiOpenTypeFeaturesForEachFunc f, void* data);

// uiNewFeaturesAttribute() creates a new uiAttribute that changes
// the font family of the text it is applied to. otf is copied; you may
// free it after uiNewFeaturesAttribute() returns.
uiAttribute* uiNewFeaturesAttribute (const(uiOpenTypeFeatures)* otf);

// uiAttributeFeatures() returns the OpenType features stored in a.
// The returned uiOpenTypeFeatures object is owned by a. It is an
// error to call this on a uiAttribute that does not hold OpenType
// features.
const(uiOpenTypeFeatures)* uiAttributeFeatures (const(uiAttribute)* a);

// uiAttributedString represents a string of UTF-8 text that can
// optionally be embellished with formatting attributes. libui
// provides the list of formatting attributes, which cover common
// formatting traits like boldface and color as well as advanced
// typographical features provided by OpenType like superscripts
// and small caps. These attributes can be combined in a variety of
// ways.
//
// Attributes are applied to runs of Unicode codepoints in the string.
// Zero-length runs are elided. Consecutive runs that have the same
// attribute type and value are merged. Each attribute is independent
// of each other attribute; overlapping attributes of different types
// do not split each other apart, but different values of the same
// attribute type do.
//
// The empty string can also be represented by uiAttributedString,
// but because of the no-zero-length-attribute rule, it will not have
// attributes.
//
// A uiAttributedString takes ownership of all attributes given to
// it, as it may need to duplicate or delete uiAttribute objects at
// any time. By extension, when you free a uiAttributedString,
// all uiAttributes within will also be freed. Each method will
// describe its own rules in more details.
//
// In addition, uiAttributedString provides facilities for moving
// between grapheme clusters, which represent a character
// from the point of view of the end user. The cursor of a text editor
// is always placed on a grapheme boundary, so you can use these
// features to move the cursor left or right by one "character".
// TODO does uiAttributedString itself need this
//
// uiAttributedString does not provide enough information to be able
// to draw itself onto a uiDrawContext or respond to user actions.
// In order to do that, you'll need to use a uiDrawTextLayout, which
// is built from the combination of a uiAttributedString and a set of
// layout-specific properties.
struct uiAttributedString;

// uiAttributedStringForEachAttributeFunc is the type of the function
// invoked by uiAttributedStringForEachAttribute() for every
// attribute in s. Refer to that function's documentation for more
// details.
alias uiAttributedStringForEachAttributeFunc = uint function (const(uiAttributedString)* s, const(uiAttribute)* a, size_t start, size_t end, void* data);

// @role uiAttributedString constructor
// uiNewAttributedString() creates a new uiAttributedString from
// initialString. The string will be entirely unattributed.
uiAttributedString* uiNewAttributedString (const(char)* initialString);

// @role uiAttributedString destructor
// uiFreeAttributedString() destroys the uiAttributedString s.
// It will also free all uiAttributes within.
void uiFreeAttributedString (uiAttributedString* s);

// uiAttributedStringString() returns the textual content of s as a
// '\0'-terminated UTF-8 string. The returned pointer is valid until
// the next change to the textual content of s.
const(char)* uiAttributedStringString (const(uiAttributedString)* s);

// uiAttributedStringLength() returns the number of UTF-8 bytes in
// the textual content of s, excluding the terminating '\0'.
size_t uiAttributedStringLen (const(uiAttributedString)* s);

// uiAttributedStringAppendUnattributed() adds the '\0'-terminated
// UTF-8 string str to the end of s. The new substring will be
// unattributed.
void uiAttributedStringAppendUnattributed (uiAttributedString* s, const(char)* str);

// uiAttributedStringInsertAtUnattributed() adds the '\0'-terminated
// UTF-8 string str to s at the byte position specified by at. The new
// substring will be unattributed; existing attributes will be moved
// along with their text.
void uiAttributedStringInsertAtUnattributed (uiAttributedString* s, const(char)* str, size_t at);

// TODO add the Append and InsertAtExtendingAttributes functions
// TODO and add functions that take a string + length

// uiAttributedStringDelete() deletes the characters and attributes of
// s in the byte range [start, end).
void uiAttributedStringDelete (uiAttributedString* s, size_t start, size_t end);

// TODO add a function to uiAttributedString to get an attribute's value at a specific index or in a specific range, so we can edit

// uiAttributedStringSetAttribute() sets a in the byte range [start, end)
// of s. Any existing attributes in that byte range of the same type are
// removed. s takes ownership of a; you should not use it after
// uiAttributedStringSetAttribute() returns.
void uiAttributedStringSetAttribute (uiAttributedString* s, uiAttribute* a, size_t start, size_t end);

// uiAttributedStringForEachAttribute() enumerates all the
// uiAttributes in s. It is an error to modify s in f. Within f, s still
// owns the attribute; you can neither free it nor save it for later
// use.
// TODO reword the above for consistency (TODO and find out what I meant by that)
// TODO define an enumeration order (or mark it as undefined); also define how consecutive runs of identical attributes are handled here and sync with the definition of uiAttributedString itself
void uiAttributedStringForEachAttribute (const(uiAttributedString)* s, uiAttributedStringForEachAttributeFunc f, void* data);

// TODO const correct this somehow (the implementation needs to mutate the structure)
size_t uiAttributedStringNumGraphemes (uiAttributedString* s);

// TODO const correct this somehow (the implementation needs to mutate the structure)
size_t uiAttributedStringByteIndexToGrapheme (uiAttributedString* s, size_t pos);

// TODO const correct this somehow (the implementation needs to mutate the structure)
size_t uiAttributedStringGraphemeToByteIndex (uiAttributedString* s, size_t pos);

// uiFontDescriptor provides a complete description of a font where
// one is needed. Currently, this means as the default font of a
// uiDrawTextLayout and as the data returned by uiFontButton.
// All the members operate like the respective uiAttributes.

struct uiFontDescriptor
{
    // TODO const-correct this or figure out how to deal with this when getting a value
    char* Family;
    double Size;
    uiTextWeight Weight;
    uiTextItalic Italic;
    uiTextStretch Stretch;
}

// uiDrawTextLayout is a concrete representation of a
// uiAttributedString that can be displayed in a uiDrawContext.
// It includes information important for the drawing of a block of
// text, including the bounding box to wrap the text within, the
// alignment of lines of text within that box, areas to mark as
// being selected, and other things.
//
// Unlike uiAttributedString, the content of a uiDrawTextLayout is
// immutable once it has been created.
//
// TODO talk about OS-specific differences with text drawing that libui can't account for...
struct uiDrawTextLayout;

// uiDrawTextAlign specifies the alignment of lines of text in a
// uiDrawTextLayout.
// TODO should this really have Draw in the name?
alias uiDrawTextAlign = uint;

enum
{
    uiDrawTextAlignLeft = 0,
    uiDrawTextAlignCenter = 1,
    uiDrawTextAlignRight = 2
}

// uiDrawTextLayoutParams describes a uiDrawTextLayout.
// DefaultFont is used to render any text that is not attributed
// sufficiently in String. Width determines the width of the bounding
// box of the text; the height is determined automatically.

// TODO const-correct this somehow
struct uiDrawTextLayoutParams
{
    uiAttributedString* String;
    uiFontDescriptor* DefaultFont;
    double Width;
    uiDrawTextAlign Align;
}

// @role uiDrawTextLayout constructor
// uiDrawNewTextLayout() creates a new uiDrawTextLayout from
// the given parameters.
//
// TODO
// - allow creating a layout out of a substring
// - allow marking compositon strings
// - allow marking selections, even after creation
// - add the following functions:
// 	- uiDrawTextLayoutHeightForWidth() (returns the height that a layout would need to be to display the entire string at a given width)
// 	- uiDrawTextLayoutRangeForSize() (returns what substring would fit in a given size)
// 	- uiDrawTextLayoutNewWithHeight() (limits amount of string used by the height)
// - some function to fix up a range (for text editing)
uiDrawTextLayout* uiDrawNewTextLayout (uiDrawTextLayoutParams* params);

// @role uiDrawFreeTextLayout destructor
// uiDrawFreeTextLayout() frees tl. The underlying
// uiAttributedString is not freed.
void uiDrawFreeTextLayout (uiDrawTextLayout* tl);

// uiDrawText() draws tl in c with the top-left point of tl at (x, y).
void uiDrawText (uiDrawContext* c, uiDrawTextLayout* tl, double x, double y);

// uiDrawTextLayoutExtents() returns the width and height of tl
// in width and height. The returned width may be smaller than
// the width passed into uiDrawNewTextLayout() depending on
// how the text in tl is wrapped. Therefore, you can use this
// function to get the actual size of the text layout.
void uiDrawTextLayoutExtents (uiDrawTextLayout* tl, double* width, double* height);

// TODO metrics functions

// TODO number of lines visible for clipping rect, range visible for clipping rect?

// uiFontButton is a button that allows users to choose a font when they click on it.
struct uiFontButton;
// uiFontButtonFont() returns the font currently selected in the uiFontButton in desc.
// uiFontButtonFont() allocates resources in desc; when you are done with the font, call uiFreeFontButtonFont() to release them.
// uiFontButtonFont() does not allocate desc itself; you must do so.
// TODO have a function that sets an entire font descriptor to a range in a uiAttributedString at once, for SetFont?
void uiFontButtonFont (uiFontButton* b, uiFontDescriptor* desc);
// TOOD SetFont, mechanics
// uiFontButtonOnChanged() sets the function that is called when the font in the uiFontButton is changed.
void uiFontButtonOnChanged (uiFontButton* b, void function (uiFontButton*, void*) f, void* data);
// uiNewFontButton() creates a new uiFontButton. The default font selected into the uiFontButton is OS-defined.
uiFontButton* uiNewFontButton ();
// uiFreeFontButtonFont() frees resources allocated in desc by uiFontButtonFont().
// After calling uiFreeFontButtonFont(), the contents of desc should be assumed to be undefined (though since you allocate desc itself, you can safely reuse desc for other font descriptors).
// Calling uiFreeFontButtonFont() on a uiFontDescriptor not returned by uiFontButtonFont() results in undefined behavior.
void uiFreeFontButtonFont (uiFontDescriptor* desc);

alias uiModifiers = uint;

enum
{
    uiModifierCtrl = 1 << 0,
    uiModifierAlt = 1 << 1,
    uiModifierShift = 1 << 2,
    uiModifierSuper = 1 << 3
}

// TODO document drag captures
struct uiAreaMouseEvent
{
    // TODO document what these mean for scrolling areas
    double X;
    double Y;

    // TODO see draw above
    double AreaWidth;
    double AreaHeight;

    int Down;
    int Up;

    int Count;

    uiModifiers Modifiers;

    ulong Held1To64;
}

alias uiExtKey = uint;

enum
{
    uiExtKeyEscape = 1,
    uiExtKeyInsert = 2, // equivalent to "Help" on Apple keyboards
    uiExtKeyDelete = 3,
    uiExtKeyHome = 4,
    uiExtKeyEnd = 5,
    uiExtKeyPageUp = 6,
    uiExtKeyPageDown = 7,
    uiExtKeyUp = 8,
    uiExtKeyDown = 9,
    uiExtKeyLeft = 10,
    uiExtKeyRight = 11,
    uiExtKeyF1 = 12, // F1..F12 are guaranteed to be consecutive
    uiExtKeyF2 = 13,
    uiExtKeyF3 = 14,
    uiExtKeyF4 = 15,
    uiExtKeyF5 = 16,
    uiExtKeyF6 = 17,
    uiExtKeyF7 = 18,
    uiExtKeyF8 = 19,
    uiExtKeyF9 = 20,
    uiExtKeyF10 = 21,
    uiExtKeyF11 = 22,
    uiExtKeyF12 = 23,
    uiExtKeyN0 = 24, // numpad keys; independent of Num Lock state
    uiExtKeyN1 = 25, // N0..N9 are guaranteed to be consecutive
    uiExtKeyN2 = 26,
    uiExtKeyN3 = 27,
    uiExtKeyN4 = 28,
    uiExtKeyN5 = 29,
    uiExtKeyN6 = 30,
    uiExtKeyN7 = 31,
    uiExtKeyN8 = 32,
    uiExtKeyN9 = 33,
    uiExtKeyNDot = 34,
    uiExtKeyNEnter = 35,
    uiExtKeyNAdd = 36,
    uiExtKeyNSubtract = 37,
    uiExtKeyNMultiply = 38,
    uiExtKeyNDivide = 39
}

struct uiAreaKeyEvent
{
    char Key;
    uiExtKey ExtKey;
    uiModifiers Modifier;

    uiModifiers Modifiers;

    int Up;
}

struct uiColorButton;
void uiColorButtonColor (uiColorButton* b, double* r, double* g, double* bl, double* a);
void uiColorButtonSetColor (uiColorButton* b, double r, double g, double bl, double a);
void uiColorButtonOnChanged (uiColorButton* b, void function (uiColorButton*, void*) f, void* data);
uiColorButton* uiNewColorButton ();

struct uiForm;
void uiFormAppend (uiForm* f, const(char)* label, uiControl* c, int stretchy);
void uiFormDelete (uiForm* f, int index);
int uiFormPadded (uiForm* f);
void uiFormSetPadded (uiForm* f, int padded);
uiForm* uiNewForm ();

alias uiAlign = uint;

enum
{
    uiAlignFill = 0,
    uiAlignStart = 1,
    uiAlignCenter = 2,
    uiAlignEnd = 3
}

alias uiAt = uint;

enum
{
    uiAtLeading = 0,
    uiAtTop = 1,
    uiAtTrailing = 2,
    uiAtBottom = 3
}

struct uiGrid;
void uiGridAppend (uiGrid* g, uiControl* c, int left, int top, int xspan, int yspan, int hexpand, uiAlign halign, int vexpand, uiAlign valign);
void uiGridInsertAt (uiGrid* g, uiControl* c, uiControl* existing, uiAt at, int xspan, int yspan, int hexpand, uiAlign halign, int vexpand, uiAlign valign);
int uiGridPadded (uiGrid* g);
void uiGridSetPadded (uiGrid* g, int padded);
uiGrid* uiNewGrid ();

// uiImage stores an image for display on screen.
// 
// Images are built from one or more representations, each with the
// same aspect ratio but a different pixel size. libui automatically
// selects the most appropriate representation for drawing the image
// when it comes time to draw the image; what this means depends
// on the pixel density of the target context. Therefore, one can use
// uiImage to draw higher-detailed images on higher-density
// displays. The typical use cases are either:
// 
// 	- have just a single representation, at which point all screens
// 	  use the same image, and thus uiImage acts like a simple
// 	  bitmap image, or
// 	- have two images, one at normal resolution and one at 2x
// 	  resolution; this matches the current expectations of some
// 	  desktop systems at the time of writing (mid-2018)
// 
// uiImage is very simple: it only supports premultiplied 32-bit
// RGBA images, and libui does not provide any image file loading
// or image format conversion utilities on top of that.
struct uiImage;

// @role uiImage constructor
// uiNewImage creates a new uiImage with the given width and
// height. This width and height should be the size in points of the
// image in the device-independent case; typically this is the 1x size.
// TODO for all uiImage functions: use const void * for const correctness
uiImage* uiNewImage (double width, double height);

// @role uiImage destructor
// uiFreeImage frees the given image and all associated resources.
void uiFreeImage (uiImage* i);

// uiImageAppend adds a representation to the uiImage.
// pixels should point to a byte array of premultiplied pixels
// stored in [R G B A] order (so ((uint8_t *) pixels)[0] is the R of the
// first pixel and [3] is the A of the first pixel). pixelWidth and
// pixelHeight is the size *in pixels* of the image, and pixelStride is
// the number *of bytes* per row of the pixels array. Therefore,
// pixels itself must be at least byteStride * pixelHeight bytes long.
// TODO see if we either need the stride or can provide a way to get the OS-preferred stride (in cairo we do)
void uiImageAppend (uiImage* i, void* pixels, int pixelWidth, int pixelHeight, int byteStride);

// uiTableValue stores a value to be passed along uiTable and
// uiTableModel.
//
// You do not create uiTableValues directly; instead, you create a
// uiTableValue of a given type using the specialized constructor
// functions.
//
// uiTableValues are immutable and the uiTableModel and uiTable
// take ownership of the uiTableValue object once returned, copying
// its contents as necessary.
struct uiTableValue;

// @role uiTableValue destructor
// uiFreeTableValue() frees a uiTableValue. You generally do not
// need to call this yourself, as uiTable and uiTableModel do this
// for you. In fact, it is an error to call this function on a uiTableValue
// that has been given to a uiTable or uiTableModel. You can call this,
// however, if you created a uiTableValue that you aren't going to
// use later, or if you called a uiTableModelHandler method directly
// and thus never transferred ownership of the uiTableValue.
void uiFreeTableValue (uiTableValue* v);

// uiTableValueType holds the possible uiTableValue types that may
// be returned by uiTableValueGetType(). Refer to the documentation
// for each type's constructor function for details on each type.
// TODO actually validate these
alias uiTableValueType = uint;

enum
{
    uiTableValueTypeString = 0,
    uiTableValueTypeImage = 1,
    uiTableValueTypeInt = 2,
    uiTableValueTypeColor = 3
}

// uiTableValueGetType() returns the type of v.
// TODO I don't like this name
uiTableValueType uiTableValueGetType (const(uiTableValue)* v);

// uiNewTableValueString() returns a new uiTableValue that contains
// str. str is copied; you do not need to keep it alive after
// uiNewTableValueString() returns.
uiTableValue* uiNewTableValueString (const(char)* str);

// uiTableValueString() returns the string stored in v. The returned
// string is owned by v. It is an error to call this on a uiTableValue
// that does not hold a string.
const(char)* uiTableValueString (const(uiTableValue)* v);

// uiNewTableValueImage() returns a new uiTableValue that contains
// the given uiImage.
// 
// Unlike other similar constructors, uiNewTableValueImage() does
// NOT copy the image. This is because images are comparatively
// larger than the other objects in question. Therefore, you MUST
// keep the image alive as long as the returned uiTableValue is alive.
// As a general rule, if libui calls a uiTableModelHandler method, the
// uiImage is safe to free once any of your code is once again
// executed.
uiTableValue* uiNewTableValueImage (uiImage* img);

// uiTableValueImage() returns the uiImage stored in v. As these
// images are not owned by v, you should not assume anything
// about the lifetime of the image (unless you created the image,
// and thus control its lifetime). It is an error to call this on a
// uiTableValue that does not hold an image.
uiImage* uiTableValueImage (const(uiTableValue)* v);

// uiNewTableValueInt() returns a uiTableValue that stores the given
// int. This can be used both for boolean values (nonzero is true, as
// in C) or progresses (in which case the valid range is -1..100
// inclusive).
uiTableValue* uiNewTableValueInt (int i);

// uiTableValueInt() returns the int stored in v. It is an error to call
// this on a uiTableValue that does not store an int.
int uiTableValueInt (const(uiTableValue)* v);

// uiNewTableValueColor() returns a uiTableValue that stores the
// given color.
uiTableValue* uiNewTableValueColor (double r, double g, double b, double a);

// uiTableValueColor() returns the color stored in v. It is an error to
// call this on a uiTableValue that does not store a color.
// TODO define whether all this, for both uiTableValue and uiAttribute, is undefined behavior or a caught error
void uiTableValueColor (const(uiTableValue)* v, double* r, double* g, double* b, double* a);

// uiTableModel is an object that provides the data for a uiTable.
// This data is returned via methods you provide in the
// uiTableModelHandler struct.
//
// uiTableModel represents data using a table, but this table does
// not map directly to uiTable itself. Instead, you can have data
// columns which provide instructions for how to render a given
// uiTable's column — for instance, one model column can be used
// to give certain rows of a uiTable a different background color.
// Row numbers DO match with uiTable row numbers.
//
// Once created, the number and data types of columns of a
// uiTableModel cannot change.
//
// Row and column numbers start at 0. A uiTableModel can be
// associated with more than one uiTable at a time.
struct uiTableModel;

// uiTableModelHandler defines the methods that uiTableModel
// calls when it needs data. Once a uiTableModel is created, these
// methods cannot change.

// TODO validate ranges; validate types on each getter/setter call (? table columns only?)
struct uiTableModelHandler
{
    // NumColumns returns the number of model columns in the
    // uiTableModel. This value must remain constant through the
    // lifetime of the uiTableModel. This method is not guaranteed
    // to be called depending on the system.
    // TODO strongly check column numbers and types on all platforms so these clauses can go away
    int function (uiTableModelHandler*, uiTableModel*) NumColumns;
    // ColumnType returns the value type of the data stored in
    // the given model column of the uiTableModel. The returned
    // values must remain constant through the lifetime of the
    // uiTableModel. This method is not guaranteed to be called
    // depending on the system.
    uiTableValueType function (uiTableModelHandler*, uiTableModel*, int) ColumnType;
    // NumRows returns the number or rows in the uiTableModel.
    // This value must be non-negative.
    int function (uiTableModelHandler*, uiTableModel*) NumRows;
    // CellValue returns a uiTableValue corresponding to the model
    // cell at (row, column). The type of the returned uiTableValue
    // must match column's value type. Under some circumstances,
    // NULL may be returned; refer to the various methods that add
    // columns to uiTable for details. Once returned, the uiTable
    // that calls CellValue will free the uiTableValue returned.
    uiTableValue* function (uiTableModelHandler* mh, uiTableModel* m, int row, int column) CellValue;
    // SetCellValue changes the model cell value at (row, column)
    // in the uiTableModel. Within this function, either do nothing
    // to keep the current cell value or save the new cell value as
    // appropriate. After SetCellValue is called, the uiTable will
    // itself reload the table cell. Under certain conditions, the
    // uiTableValue passed in can be NULL; refer to the various
    // methods that add columns to uiTable for details. Once
    // returned, the uiTable that called SetCellValue will free the
    // uiTableValue passed in.
    void function (uiTableModelHandler*, uiTableModel*, int, int, const(uiTableValue)*) SetCellValue;
}

// @role uiTableModel constructor
// uiNewTableModel() creates a new uiTableModel with the given
// handler methods.
uiTableModel* uiNewTableModel (uiTableModelHandler* mh);

// @role uiTableModel destructor
// uiFreeTableModel() frees the given table model. It is an error to
// free table models currently associated with a uiTable.
void uiFreeTableModel (uiTableModel* m);

// uiTableModelRowInserted() tells any uiTable associated with m
// that a new row has been added to m at index index. You call
// this function when the number of rows in your model has
// changed; after calling it, NumRows() should returm the new row
// count.
void uiTableModelRowInserted (uiTableModel* m, int newIndex);

// uiTableModelRowChanged() tells any uiTable associated with m
// that the data in the row at index has changed. You do not need to
// call this in your SetCellValue() handlers, but you do need to call
// this if your data changes at some other point.
void uiTableModelRowChanged (uiTableModel* m, int index);

// uiTableModelRowDeleted() tells any uiTable associated with m
// that the row at index index has been deleted. You call this
// function when the number of rows in your model has changed;
// after calling it, NumRows() should returm the new row
// count.
// TODO for this and Inserted: make sure the "after" part is right; clarify if it's after returning or after calling
void uiTableModelRowDeleted (uiTableModel* m, int oldIndex);
// TODO reordering/moving

// uiTableModelColumnNeverEditable and
// uiTableModelColumnAlwaysEditable are the value of an editable
// model column parameter to one of the uiTable create column
// functions; if used, that jparticular uiTable colum is not editable
// by the user and always editable by the user, respectively.
enum uiTableModelColumnNeverEditable = -1;
enum uiTableModelColumnAlwaysEditable = -2;

// uiTableTextColumnOptionalParams are the optional parameters
// that control the appearance of the text column of a uiTable.

// uiTableParams defines the parameters passed to uiNewTable().

struct uiTableTextColumnOptionalParams
{
    // ColorModelColumn is the model column containing the
    // text color of this uiTable column's text, or -1 to use the
    // default color.
    //
    // If CellValue() for this column for any cell returns NULL, that
    // cell will also use the default text color.
    int ColorModelColumn;
}

struct uiTableParams
{
    // Model is the uiTableModel to use for this uiTable.
    // This parameter cannot be NULL.
    uiTableModel* Model;
    // RowBackgroundColorModelColumn is a model column
    // number that defines the background color used for the
    // entire row in the uiTable, or -1 to use the default color for
    // all rows.
    //
    // If CellValue() for this column for any row returns NULL, that
    // row will also use the default background color.
    int RowBackgroundColorModelColumn;
}

// uiTable is a uiControl that shows tabular data, allowing users to
// manipulate rows of such data at a time.
struct uiTable;
// uiTableAppendTextColumn() appends a text column to t.
// name is displayed in the table header.
// textModelColumn is where the text comes from.
// If a row is editable according to textEditableModelColumn,
// SetCellValue() is called with textModelColumn as the column.
void uiTableAppendTextColumn (
    uiTable* t,
    const(char)* name,
    int textModelColumn,
    int textEditableModelColumn,
    uiTableTextColumnOptionalParams* textParams);

// uiTableAppendImageColumn() appends an image column to t.
// Images are drawn at icon size, appropriate to the pixel density
// of the screen showing the uiTable.
void uiTableAppendImageColumn (
    uiTable* t,
    const(char)* name,
    int imageModelColumn);

// uiTableAppendImageTextColumn() appends a column to t that
// shows both an image and text.
void uiTableAppendImageTextColumn (
    uiTable* t,
    const(char)* name,
    int imageModelColumn,
    int textModelColumn,
    int textEditableModelColumn,
    uiTableTextColumnOptionalParams* textParams);

// uiTableAppendCheckboxColumn appends a column to t that
// contains a checkbox that the user can interact with (assuming the
// checkbox is editable). SetCellValue() will be called with
// checkboxModelColumn as the column in this case.
void uiTableAppendCheckboxColumn (
    uiTable* t,
    const(char)* name,
    int checkboxModelColumn,
    int checkboxEditableModelColumn);

// uiTableAppendCheckboxTextColumn() appends a column to t
// that contains both a checkbox and text.
void uiTableAppendCheckboxTextColumn (
    uiTable* t,
    const(char)* name,
    int checkboxModelColumn,
    int checkboxEditableModelColumn,
    int textModelColumn,
    int textEditableModelColumn,
    uiTableTextColumnOptionalParams* textParams);

// uiTableAppendProgressBarColumn() appends a column to t
// that displays a progress bar. These columns work like
// uiProgressBar: a cell value of 0..100 displays that percentage, and
// a cell value of -1 displays an indeterminate progress bar.
void uiTableAppendProgressBarColumn (
    uiTable* t,
    const(char)* name,
    int progressModelColumn);

// uiTableAppendButtonColumn() appends a column to t
// that shows a button that the user can click on. When the user
// does click on the button, SetCellValue() is called with a NULL
// value and buttonModelColumn as the column.
// CellValue() on buttonModelColumn should return the text to show
// in the button.
void uiTableAppendButtonColumn (
    uiTable* t,
    const(char)* name,
    int buttonModelColumn,
    int buttonClickableModelColumn);

// uiNewTable() creates a new uiTable with the specified parameters.
uiTable* uiNewTable (uiTableParams* params);

